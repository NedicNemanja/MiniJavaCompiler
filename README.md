<a name="hw2">Homework 2 – MiniJava Static Checking (Semantic Analysis)</a></h2>
<p>This homework introduces your semester project, which consists of building a compiler for MiniJava, a subset of Java. MiniJava is designed so that its programs can be compiled by a full Java compiler like javac.</p>
<p>Here is a partial, textual description of the language. Much of it <strong>can be safely ignored</strong> (most things are well defined in the grammar or derived from the requirement that each MiniJava program is also a Java program):</p>
<ul>
<li><p>MiniJava is fully object-oriented, like Java. It does not allow global functions, only classes, fields and methods. The basic types are int, boolean, and int [] which is an array of int. You can build classes that contain fields of these basic types or of other classes. Classes contain methods with arguments of basic or class types, etc.</p></li>
<li><p>MiniJava supports single inheritance but not interfaces. It does not support function overloading, which means that each method name must be unique. In addition, all methods are inherently polymorphic (i.e., “virtual” in C++ terminology). This means that foo can be defined in a subclass if it has the same return type and argument types (ordered) as in the parent, but it is an error if it exists with other argument types or return type in the parent. Also all methods must have a return type--there are no void methods. Fields in the base and derived class are allowed to have the same names, and are essentially different fields.</p></li>
<li>All MiniJava methods are “public” and all fields “protected”. A class method cannot access fields of another class, with the exception of its superclasses. Methods are visible, however. A class's own methods can be called via “this”. E.g., this.foo(5) calls the object's own foo method, a.foo(5) calls the foo method of object a. Local variables are defined only at the beginning of a method. A name cannot be repeated in local variables (of the same method) and cannot be repeated in fields (of the same class). A local variable x shadows a field x of the surrounding class.</li>
<li><p>In MiniJava, constructors and destructors are not defined. The new operator calls a default void constructor. In addition, there are no inner classes and there are no static methods or fields. By exception, the pseudo-static method “main” is handled specially in the grammar. A MiniJava program is a file that begins with a special class that contains the main method and specific arguments that are not used. The special class has no fields. After it, other classes are defined that can have fields and methods.<br>
Notably, an A class can contain a field of type B, where B is defined later in the file. But when we have "class B extends A”, A must be defined before B. As you'll notice in the grammar, MiniJava offers very simple ways to construct expressions and only allows &lt; comparisons. There are no lists of operations, e.g., 1 + 2 + 3, but a method call on one object may be used as an argument for another method call. In terms of logical operators, MiniJava allows the logical and ("&amp;&amp;") and the logical not ("!"). For int arrays, the assignment and [] operators are allowed, as well as the a.length expression, which returns the size of array a. We have “while” and “if” code blocks. The latter are always followed by an “else”. Finally, the assignment "A a = new B();" when B extends A is correct, and the same applies when a method expects a parameter of type A and a B instance is given instead.</p></li>
</ul>
<p>The MiniJava grammar in BNF can be downloaded <a href="project_files/minijava-new/minijava.html">here</a>. You can make small changes to grammar, but you must accept everything that MiniJava accepts and reject anything that is rejected by the full Java language. Making changes is not recommended because it will make your job harder in subsequent homework assignments. Normally you won't need to touch the grammar.</p>
<p>The MiniJava grammar in JavaCC form is <a href="project_files/minijava-new/minijava.jj">here</a>. You will use the JTB tool to convert it into a grammar that produces class hierarchies. Then you will write one or more visitors who will take control over the MiniJava input file and will tell whether it is semantically correct, or will print an error message. It isn’t necessary for the compiler to report precisely what error it encountered and compilation can end at the first error. But you should not miss errors or report errors in correct programs.</p>
<p>The visitors you will build should be subclasses of the visitors generated by JTB, but they may also contain methods and fields to hold information during static checking, to transfer information from one visitor to the next, etc. In the end, you will have a Main class that runs the semantic analysis initiating the parser that was produced by JavaCC and executing the visitors you wrote. You will turn in your grammar file, if you have made changes, otherwise just the code produced by JavaCC and JTB alongside your own classes that implement the visitors, etc. and a Main. The Main should parse and statically check all the MiniJava files that are given as arguments.</p>
<p>Also, for every MiniJava file, your program should store and print some useful data for every class such as the names and the offsets of every variable and method this class contains. For MiniJava we have only three types of variables (int, boolean and pointers). Ints are stored in 4 bytes, booleans in 1 byte and pointers in 8 bytes (we consider functions and int arrays as pointers). Corresponding offsets are shown in the example below:</p>
<p>Input:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">  <span class="kw">class</span> A{
      <span class="dt">int</span> i;
      <span class="dt">boolean</span> flag;
      <span class="dt">int</span> j;
      <span class="kw">public</span> <span class="dt">int</span> <span class="fu">foo</span>() {}
      <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">fa</span>() {}
  }

  <span class="kw">class</span> B <span class="kw">extends</span> A{
      A type;
      <span class="dt">int</span> k;
      <span class="kw">public</span> <span class="dt">int</span> <span class="fu">foo</span>() {}
      <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">bla</span>() {}
  }</code></pre></div>
<p>Output:</p>
<pre><code>  A.i : 0
  A.flag : 4
  A.j : 5
  A.foo : 0
  A.fa: 8
  B.type : 9
  B.k : 17
  B.bla : 16</code></pre>
<p>There will be a tutorial for JavaCC and JTB. You can use <a href="project_files/minijava-examples-new/">these</a> files as MiniJava examples and to test your program. Obviously you are free to make up your own files, however the homework will be graded purely on how your compiler performs on all the files we will test it against (both the above sample files and others). You can share ideas and test files, but you are not allowed to share code.</p>
<p>Your program should run as follows:</p>
<pre><code>java [MainClassName] [file1] [file2] ... [fileN]</code></pre>
<p>That is, your program must perform semantic analysis on all files given as arguments. May the Force be with you!</p>




<h2 id="part-3"><a name="hw3">Homework 3 - Generating intermediate code (MiniJava -&gt; LLVM)</a></h2>
<p>In this part of the project you have to write visitors that convert MiniJava code into the intermediate representation used by the LLVM compiler project. The MiniJava language is the same as in the previous exercise. The LLVM language is documented in the <a href="https://llvm.org/docs/LangRef.html#instruction-reference">LLVM Language Reference Manual</a>, although you will use only a subset of the instructions.</p>
<h2 id="types">Types</h2>
<p>Some of the available types that might be useful are:</p>
<ul>
<li><code>i1</code> - a single bit, used for booleans (practically takes up one byte)</li>
<li><code>i8</code> - a single byte</li>
<li><code>i8*</code> - similar to a char* pointer</li>
<li><code>i32</code> - a single integer</li>
<li><code>i32*</code> - a pointer to an integer, can be used to point to an integer array</li>
<li>static arrays, e.g., <code>[20 x i8]</code> - a constant array of 20 characters</li>
</ul>
<h2 id="instructions-to-be-used">Instructions to be used</h2>
<ul>
<li><p><code>declare</code> is used for the declaration of external methods. Only a few specific methods (e.g., <code>calloc</code>, <code>printf</code>) need to be declared.<br>
Example: <code>declare i32 @puts(i8*)</code></p></li>
<li><p><code>define</code> is used for defining our own methods. The return and argument types need to be specified, and the method needs to end with a <code>ret</code> instruction of the same type.<br>
Example: <code>define i32 @main(i32 %argc, i8** argv) {...}</code></p></li>
<li><p><code>ret</code> is the return instruction. It is used to return the control flow and a value to the caller of the current function. Example: <code>ret i32 %rv</code></p></li>
<li><p><code>alloca</code> is used to allocate space on the stack of the current function for local variables. It returns a <em>pointer</em> to the given type. This space is freed when the method returns.<br>
Example: <code>%ptr = alloca i32</code></p></li>
<li><p><code>store</code> is used to store a value to a memory location. The parameters are the value to be stored and a pointer to the memory.<br>
Example: <code>store i32 %val, i32* %ptr</code></p></li>
<li><p><code>load</code> is used to load a value from a memory location. The parameters are the type of the value and a pointer to the memory.<br>
Example: <code>%val = load i32, i32* %ptr</code></p></li>
<li><p><code>call</code> is used to call a method. The result can be assigned to a register. (LLVM bitcode temporary variables are called "registers".) The return type and parameters (with their types) need to be specified.<br>
Example: <code>%result = call i8* @calloc(i32 1, i32 %val)</code></p></li>
<li><p><code>add, and, sub, mul, xor</code> are used for mathematical operations. The result is the same type as the operands.<br>
Example: <code>%sum = add i32 %a, %b</code></p></li>
<li><p><code>icmp</code> is used for comparing two operands. <code>icmp slt</code> for instance does a signed comparison of the operands and will return <code>i1 1</code> if the first operand is less than the second, otherwise <code>i1 0</code>.<br>
Example: <code>%case = icmp slt i32 %a, %b</code></p></li>
<li><p><code>br</code> with a <code>i1</code> operand and two labels will jump to the first label if the <code>i1</code> is one, and to the second label otherwise.<br>
Example: <code>br i1 %case, label %if, label %else</code></p></li>
<li><p><code>br</code> with only a single label will jump to that label.<br>
Example: <code>br label %goto</code></p></li>
<li><p><code>label:</code> declares a label with the given name. The instruction before declaring a label needs to be a <code>br</code> operation, even if that <code>br</code> is simply a jump to the label.<br>
Example: <code>label123:</code></p></li>
<li><p><code>bitcast</code> is used to cast between different pointer types. It takes the value and type to be cast, and the type that it will be cast to.<br>
Example: <code>%ptr = bitcast i32* %ptr2 to i8**</code></p></li>
<li><p><code>getelementptr</code> is used to get the pointer to an element of an array from a pointer to that array and the index of the element. The result is also a pointer to the type that is passed as the first parameter (in the case below it's an <code>i8*</code>). This example is like doing <code>ptr_idx = &amp;ptr[idx]</code> in C (you still need to do a <code>load</code> to get the actual value at that position).<br>
Example: <code>%ptr_idx = getelementptr i8, i8* %ptr, i32 %idx</code></p></li>
<li><p><code>constant</code> is used to define a constant, such as a string. The size of the constant needs to be declared too. In the example below, the string is 12 bytes (<code>[12 x i8]</code>). The result is a pointer to the given type (in the example below, <code>@.str</code> is a <code>[12 x i8]*</code>).<br>
Example: <code>@.str = constant [12 x i8] c"Hello world\00"</code></p></li>
<li><p><code>global</code> is used for declaring global variables - something you will need to do for creating v-tables. Just like <code>constant</code>, the result is a pointer to the given type.<br>
Example:<br>
<code>@.vtable = global [2 x i8*] [i8* bitcast (i32 ()* @func1 to i8*), i8* bitcast (i8* (i32, i32*)* @func2 to i8*)]</code></p></li>
<li><p><code>phi</code> is used for selecting a value from previous basic blocks, depending on which one was executed before the current block. Phi instructions must be the first in a basic block. It takes as arguments a list of pairs. Each pair contains the value to be selected and the predecessor block for that value. This is necessary in single-assignment languages, in places where multiple control-flow paths join, such as if-else statements, if one wants to select a value from the different paths. In the context of the exercise, you will need this for short-circuiting and (&amp;&amp;) expressions.<br>
Example:<br>
<code>br i1 1, label %lb1, label %lb2</code><br>
<code>lb1:</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>%a = add i32 0, 100</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>br label %lb3</code><br>
<code>lb2:</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>%b = add i32 0, 200</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>br label %lb3</code><br>
<code>lb3:</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>%c = phi i32 [%a, %lb1], [%b, %lb2]</code></p></li>
</ul>
<h2 id="v-table">V-table</h2>
<p>If you do not remember or haven't seen how a virtual table (v-table) is constructed, essentially it is a table of function pointers, pointed at by the first 8 bytes of an object. The v-table defines an address for each dynamic function the object supports. Consider a function <code>foo</code> in position 0 and <code>bar</code> in position 1 of the table (with actual offset 8). If a method is overridden, the overriding version is inserted in the same location of the virtual table as the overridden version. Virtual calls are implemented by finding the address of the function to call through the virtual table. If we wanted to depict this in C, imagine that object <code>obj</code> is located at location <code>x</code> and we are calling <code>foo</code> which is in the 3rd position (offset 16) of the v-table. The address of the function that is going to be called is in memory location <code>(*x) + 16</code>.</p>
<h2 id="execution">Execution</h2>
<p>You will need to execute the produced LLVM IR files in order to see that their output is the same as compiling the input java file with <code>javac</code> and executing it with <code>java</code>. To do that, you will need Clang with version &gt;=4.0.0. You may download it on your Linux machine, or use it via SSH on the linuxvm machines.</p>
<h3 id="in-ubuntu-trusty">In Ubuntu Trusty</h3>
<ol style="list-style-type: decimal">
<li><code>sudo apt update &amp;&amp; sudo apt install clang-4.0</code></li>
<li>Save the code to a file (e.g. <code>ex.ll</code>)</li>
<li><code>clang-4.0 -o out1 ex.ll</code></li>
<li><code>./out1</code></li>
</ol>
<h3 id="in-linuxvm-machines">In linuxvm machines</h3>
<ol style="list-style-type: decimal">
<li><code>/home/users/thp06/clang/clang -o out1 ex.ll</code></li>
<li><code>./out1</code></li>
</ol>
<h2 id="deliverable">Deliverable</h2>
<p>Your program should run as follows:<br>
<code>java [MainClassName] [file1.java] [file2.java] ... [fileN.java]</code><br>
That is, your program must compile to LLVM IR all .java files given as arguments. Moreover, the outputs must be stored in files named <code>file1.ll</code>, <code>file2.ll</code>, ... <code>fileN.ll</code> respectively.</p>
<h2 id="tips">Tips</h2>
<ul>
<li>You will need to use a lot of registers in order to 'glue' expressions together. This means that each visitor will produce the code for storing the value of an expression to a register, and then return the name of that register so that other expressions may use it, if necessary.</li>
<li>Registers are single-assignment. This means you can only write to them once (but read any number of times). This also implies that registers cannot be used for local variables of the source program. Instead, you will allocate space on the stack using <code>alloca</code> and keep the address in a register. You will use the <code>load</code> and <code>store</code> instructions to read and write to that local variable.</li>
<li>Because registers are single-assignment, you will probably need to keep a counter to produce new ones. For example, you may produce registers of the form <code>%_1</code>, <code>%_2</code>, etc.</li>
<li>You will only support compilation to a 64-bit architecture: pointers are 8-bytes long.</li>
<li>Everything new in Java is initialized to zeroes.</li>
<li>Memory allocated with <code>@calloc</code> will leak since you're not implementing a Garbage Collector, but that's fine for this homework.</li>
<li>You will need to check each array access in order not to write or read beyond the limits of an array. If an illegal read/write is attempted, you will print the message "Out of bounds" and the program will exit (you may call the <code>@throw_oob</code> defined below for that). Of course, you need to know the length of an array for that.</li>
<li>You will also need to check if an array is allocated with a negative length, and do the same process as above in that case.</li>
<li>You may see some examples of LLVM code produced for different Java input files <a href="http://cgi.di.uoa.gr/~thp06/project_files/llvm-examples/">here</a> (corresponding to the earlier MiniJava <a href="http://cgi.di.uoa.gr/~thp06/project_files/minijava-examples-new/">examples</a> from HW2).</li>
<li>You may define the following helper methods once in your output files, in order to be able to call <code>@calloc</code>, <code>@print_int</code> and <code>@throw_oob</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span class="kw">declare</span> <span class="dt">i8</span>* <span class="fu">@calloc</span>(<span class="dt">i32</span>, <span class="dt">i32</span>)
<span class="kw">declare</span> <span class="dt">i32</span> <span class="fu">@printf</span>(<span class="dt">i8</span>*, ...)
<span class="kw">declare</span> <span class="dt">void</span> <span class="fu">@exit</span>(<span class="dt">i32</span>)

<span class="fu">@_cint</span> = <span class="kw">constant</span> [<span class="dv">4</span> x <span class="dt">i8</span>] c<span class="st">"%d\0a\00"</span>
<span class="fu">@_cOOB</span> = <span class="kw">constant</span> [<span class="dv">15</span> x <span class="dt">i8</span>] c<span class="st">"Out of bounds\0a\00"</span>
<span class="kw">define</span> <span class="dt">void</span> <span class="fu">@print_int</span>(<span class="dt">i32</span> <span class="fu">%i</span>) {
    <span class="fu">%_str</span> = <span class="kw">bitcast</span> [<span class="dv">4</span> x <span class="dt">i8</span>]* <span class="fu">@_cint</span> <span class="kw">to</span> <span class="dt">i8</span>*
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%_str</span>, <span class="dt">i32</span> <span class="fu">%i</span>)
    <span class="kw">ret</span> <span class="dt">void</span>
}

<span class="kw">define</span> <span class="dt">void</span> <span class="fu">@throw_oob</span>() {
    <span class="fu">%_str</span> = <span class="kw">bitcast</span> [<span class="dv">15</span> x <span class="dt">i8</span>]* <span class="fu">@_cOOB</span> <span class="kw">to</span> <span class="dt">i8</span>*
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%_str</span>)
    <span class="kw">call</span> <span class="dt">void</span> <span class="fu">@exit</span>(<span class="dt">i32</span> <span class="dv">1</span>)
    <span class="kw">ret</span> <span class="dt">void</span>
}</code></pre></div>
<h2 id="example-program">Example program</h2>
<p>The program below demonstrates all of the above instructions. It creates an array of 3 methods (add, sub and mul), calls all of them with the same arguments and prints the results.</p>
<div class="sourceCode"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span class="fu">@.funcs</span> = <span class="kw">global</span> [<span class="dv">3</span> x <span class="dt">i8</span>*] [<span class="dt">i8</span>* <span class="kw">bitcast</span> (<span class="dt">i32</span> (<span class="dt">i32</span>*, <span class="dt">i32</span>*)* <span class="fu">@add</span> <span class="kw">to</span> <span class="dt">i8</span>*),
                            <span class="dt">i8</span>* <span class="kw">bitcast</span> (<span class="dt">i32</span> (<span class="dt">i32</span>*, <span class="dt">i32</span>*)* <span class="fu">@sub</span> <span class="kw">to</span> <span class="dt">i8</span>*),
                            <span class="dt">i8</span>* <span class="kw">bitcast</span> (<span class="dt">i32</span> (<span class="dt">i32</span>*, <span class="dt">i32</span>*)* <span class="fu">@mul</span> <span class="kw">to</span> <span class="dt">i8</span>*)]

<span class="kw">declare</span> <span class="dt">i32</span> <span class="fu">@printf</span>(<span class="dt">i8</span>*, ...)
<span class="fu">@.comp_str</span> = <span class="kw">constant</span> [<span class="dv">15</span> x <span class="dt">i8</span>] c<span class="st">"%d %c %d = %d\0A\00"</span>
<span class="fu">@.ret_val</span> = <span class="kw">constant</span> [<span class="dv">20</span> x <span class="dt">i8</span>] c<span class="st">"Returned value: %d\0A\00"</span>

<span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@main</span>() {
    <span class="co">; allocate local variables</span>
    <span class="fu">%ptr_a</span> = <span class="kw">alloca</span> <span class="dt">i32</span>
    <span class="fu">%ptr_b</span> = <span class="kw">alloca</span> <span class="dt">i32</span>
    <span class="fu">%count</span> = <span class="kw">alloca</span> <span class="dt">i32</span>

    <span class="co">; initialize var values</span>
    <span class="kw">store</span> <span class="dt">i32</span> <span class="dv">100</span>, <span class="dt">i32</span>* <span class="fu">%ptr_a</span>
    <span class="kw">store</span> <span class="dt">i32</span> <span class="dv">50</span>, <span class="dt">i32</span>* <span class="fu">%ptr_b</span>
    <span class="kw">store</span> <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span>* <span class="fu">%count</span>
    <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%loopstart</span>

  <span class="fu">loopstart:</span>
    <span class="co">;load %i from %count</span>
    <span class="fu">%i</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%count</span>
    <span class="co">; while %i &lt; 3</span>
    <span class="fu">%fin</span> = <span class="kw">icmp</span> <span class="kw">slt</span> <span class="dt">i32</span> <span class="fu">%i</span>, <span class="dv">3</span>
    <span class="kw">br</span> <span class="dt">i1</span> <span class="fu">%fin</span>, <span class="dt">label</span> <span class="fu">%next</span>, <span class="dt">label</span> <span class="fu">%end</span>

  <span class="fu">next:</span>
    <span class="co">; get pointer to %i'th element of the @.funcs array</span>
    <span class="fu">%func_ptr</span> = <span class="kw">getelementptr</span> [<span class="dv">3</span> x <span class="dt">i8</span>*], [<span class="dv">3</span> x <span class="dt">i8</span>*]* <span class="fu">@.funcs</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="fu">%i</span>
    <span class="co">; load %i'th element that contains an i8* to the method</span>
    <span class="fu">%func_addr</span> = <span class="kw">load</span> <span class="dt">i8</span>*, <span class="dt">i8</span>** <span class="fu">%func_ptr</span>
    <span class="co">; cast i8* to actual method type in order to call it</span>
    <span class="fu">%func</span> = <span class="kw">bitcast</span> <span class="dt">i8</span>* <span class="fu">%func_addr</span> <span class="kw">to</span> <span class="dt">i32</span> (<span class="dt">i32</span>*, <span class="dt">i32</span>*)*
    <span class="co">; call casted method</span>
    <span class="fu">%result</span> = <span class="kw">call</span> <span class="dt">i32</span> <span class="fu">%func</span>(<span class="dt">i32</span>* <span class="fu">%ptr_a</span>, <span class="dt">i32</span>* <span class="fu">%ptr_b</span>)
    
    <span class="co">; print result</span>
    <span class="fu">%str</span> = <span class="kw">bitcast</span> [<span class="dv">20</span> x <span class="dt">i8</span>]* <span class="fu">@.ret_val</span> <span class="kw">to</span> <span class="dt">i8</span>*
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%str</span>, <span class="dt">i32</span> <span class="fu">%result</span>)

    <span class="co">; increase %i and store to %count</span>
    <span class="fu">%next_i</span> = <span class="kw">add</span> <span class="dt">i32</span> <span class="fu">%i</span>, <span class="dv">1</span>
    <span class="kw">store</span> <span class="dt">i32</span> <span class="fu">%next_i</span>, <span class="dt">i32</span>* <span class="fu">%count</span>
    <span class="co">; go to loopstart</span>
    <span class="kw">br</span> <span class="dt">label</span> <span class="fu">%loopstart</span>

  <span class="fu">end:</span>
    <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span>
}

<span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@add</span>(<span class="dt">i32</span>* <span class="fu">%a</span>, <span class="dt">i32</span>* <span class="fu">%b</span>) {
    <span class="fu">%str</span> = <span class="kw">bitcast</span> [<span class="dv">15</span> x <span class="dt">i8</span>]* <span class="fu">@.comp_str</span> <span class="kw">to</span> <span class="dt">i8</span>*

    <span class="co">; load values from addresses</span>
    <span class="fu">%val_a</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%a</span>
    <span class="fu">%val_b</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%b</span>

    <span class="co">; add them and print the result</span>
    <span class="fu">%res</span> = <span class="kw">add</span> <span class="dt">i32</span> <span class="fu">%val_a</span>, <span class="fu">%val_b</span>
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%str</span>, <span class="dt">i32</span> <span class="fu">%val_a</span>, [<span class="dv">1</span> x <span class="dt">i8</span>] c<span class="st">"+"</span>, <span class="dt">i32</span> <span class="fu">%val_b</span>, <span class="dt">i32</span> <span class="fu">%res</span>)

    <span class="co">; return the result</span>
    <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%res</span>
}

<span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@sub</span>(<span class="dt">i32</span>* <span class="fu">%a</span>, <span class="dt">i32</span>* <span class="fu">%b</span>) {
    <span class="co">; similar as above</span>
    <span class="fu">%str</span> = <span class="kw">bitcast</span> [<span class="dv">15</span> x <span class="dt">i8</span>]* <span class="fu">@.comp_str</span> <span class="kw">to</span> <span class="dt">i8</span>*
    <span class="fu">%val_a</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%a</span>
    <span class="fu">%val_b</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%b</span>
    <span class="fu">%res</span> = <span class="kw">sub</span> <span class="dt">i32</span> <span class="fu">%val_a</span>, <span class="fu">%val_b</span>
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%str</span>, <span class="dt">i32</span> <span class="fu">%val_a</span>, [<span class="dv">1</span> x <span class="dt">i8</span>] c<span class="st">"-"</span>, <span class="dt">i32</span> <span class="fu">%val_b</span>, <span class="dt">i32</span> <span class="fu">%res</span>)
    <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%res</span>
}

<span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@mul</span>(<span class="dt">i32</span>* <span class="fu">%a</span>, <span class="dt">i32</span>* <span class="fu">%b</span>) {
    <span class="co">; similar as above</span>
    <span class="fu">%str</span> = <span class="kw">bitcast</span> [<span class="dv">15</span> x <span class="dt">i8</span>]* <span class="fu">@.comp_str</span> <span class="kw">to</span> <span class="dt">i8</span>*
    <span class="fu">%val_a</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%a</span>
    <span class="fu">%val_b</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%b</span>
    <span class="fu">%res</span> = <span class="kw">mul</span> <span class="dt">i32</span> <span class="fu">%val_a</span>, <span class="fu">%val_b</span>
    <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="fu">%str</span>, <span class="dt">i32</span> <span class="fu">%val_a</span>, [<span class="dv">1</span> x <span class="dt">i8</span>] c<span class="st">"*"</span>, <span class="dt">i32</span> <span class="fu">%val_b</span>, <span class="dt">i32</span> <span class="fu">%res</span>)
    <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%res</span>
}</code>
